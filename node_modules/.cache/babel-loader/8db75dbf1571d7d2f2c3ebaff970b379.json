{"ast":null,"code":"'use strict';\n\nmodule.exports = function (timestamp) {\n  var wasWindowIdled = timestamp - this.previousTimeStamp > 100;\n  var isLoop = this.states[this.activeState].loop !== undefined ? this.states[this.activeState].loop : true;\n  var progressPercent, isLooping, nextGradient; // If tab was inactive then resumed, reset the previous timestamp\n\n  if (this.previousTimeStamp === null || wasWindowIdled) {\n    this.previousTimeStamp = timestamp;\n  } // Compute progress and save the timestamp\n\n\n  this.progress = this.progress + (timestamp - this.previousTimeStamp);\n  progressPercent = (this.progress / this.activetransitionSpeed * 100).toFixed(2);\n  this.previousTimeStamp = timestamp; // Set the new gradient colors in a property\n\n  this.refreshColorsAndPos(progressPercent); // Continue the animation or prepare for the next one\n\n  if (progressPercent < 100) {\n    this.animation = requestAnimationFrame(this.animateColors.bind(this));\n  } else {\n    // if the current animation index is inferior to the penultimate gradient\n    // or to the last gradient with the loop mode activated\n    if (this.channelsIndex < this.states[this.activeState].gradients.length - 2 || isLoop) {\n      // Set the active transition speed to the active state one after changing state\n      if (this.isChangingState) {\n        this.activetransitionSpeed = this.states[this.activeState].transitionSpeed || 5000;\n        this.isChangingState = false;\n      } // Resetting properties\n\n\n      this.previousTimeStamp = null;\n      this.progress = 0;\n      this.channelsIndex++;\n      isLooping = false; // If it's going to loop or if it's the transition after the loop\n\n      if (this.channelsIndex === this.states[this.activeState].gradients.length - 1) {\n        isLooping = true;\n      } else if (this.channelsIndex === this.states[this.activeState].gradients.length) {\n        this.channelsIndex = 0;\n      } // Checking the next gradient to send in args of an event and a callback\n\n\n      nextGradient = this.states[this.activeState].gradients[this.channelsIndex + 1] === undefined ? this.states[this.activeState].gradients[0] : this.states[this.activeState].gradients[this.channelsIndex + 1]; // Compute the colors for the transition and render a new frame\n\n      this.setColors();\n      this.animation = requestAnimationFrame(this.animateColors.bind(this)); // Callback and Event\n\n      if (this.callbacks.onGradientChange) {\n        this.callbacks.onGradientChange({\n          isLooping: isLooping,\n          colorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\n          colorsTo: nextGradient,\n          activeState: this.activeState\n        });\n      }\n\n      this.canvas.dispatchEvent(this.events.gradientChange({\n        isLooping: isLooping,\n        colorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\n        colorsTo: nextGradient,\n        activeState: this.activeState\n      })); // Else if it was the last gradient on the list and the loop mode is off\n    } else {\n      cancelAnimationFrame(this.animation); // Callback and Event\n\n      if (this.callbacks.onEnd) this.callbacks.onEnd();\n      this.canvas.dispatchEvent(new CustomEvent('granim:end'));\n    }\n  }\n};","map":{"version":3,"sources":["/Users/sylv/Desktop/coding/portfolio-site/node_modules/granim/lib/animateColors.js"],"names":["module","exports","timestamp","wasWindowIdled","previousTimeStamp","isLoop","states","activeState","loop","undefined","progressPercent","isLooping","nextGradient","progress","activetransitionSpeed","toFixed","refreshColorsAndPos","animation","requestAnimationFrame","animateColors","bind","channelsIndex","gradients","length","isChangingState","transitionSpeed","setColors","callbacks","onGradientChange","colorsFrom","colorsTo","canvas","dispatchEvent","events","gradientChange","cancelAnimationFrame","onEnd","CustomEvent"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nmodule.exports = function(timestamp) {\r\n\tvar wasWindowIdled = timestamp - this.previousTimeStamp > 100;\r\n\tvar isLoop = this.states[this.activeState].loop !== undefined ? this.states[this.activeState].loop : true;\r\n\tvar progressPercent, isLooping, nextGradient;\r\n\r\n\t// If tab was inactive then resumed, reset the previous timestamp\r\n\tif (this.previousTimeStamp === null || wasWindowIdled) {\r\n\t\tthis.previousTimeStamp = timestamp;\r\n\t}\r\n\r\n\t// Compute progress and save the timestamp\r\n\tthis.progress = this.progress + (timestamp - this.previousTimeStamp);\r\n\tprogressPercent = (this.progress / this.activetransitionSpeed * 100).toFixed(2);\r\n\tthis.previousTimeStamp = timestamp;\r\n\r\n\t// Set the new gradient colors in a property\r\n\tthis.refreshColorsAndPos(progressPercent);\r\n\r\n\t// Continue the animation or prepare for the next one\r\n\tif (progressPercent < 100) {\r\n\t\tthis.animation = requestAnimationFrame(this.animateColors.bind(this));\r\n\r\n\t} else {\r\n\t\t// if the current animation index is inferior to the penultimate gradient\r\n\t\t// or to the last gradient with the loop mode activated\r\n\t\tif (this.channelsIndex < this.states[this.activeState].gradients.length - 2 || isLoop) {\r\n\r\n\t\t\t// Set the active transition speed to the active state one after changing state\r\n\t\t\tif (this.isChangingState) {\r\n\t\t\t\tthis.activetransitionSpeed = this.states[this.activeState].transitionSpeed || 5000;\r\n\t\t\t\tthis.isChangingState = false;\r\n\t\t\t}\r\n\r\n\t\t\t// Resetting properties\r\n\t\t\tthis.previousTimeStamp = null;\r\n\t\t\tthis.progress = 0;\r\n\t\t\tthis.channelsIndex++;\r\n\t\t\tisLooping = false;\r\n\r\n\t\t\t// If it's going to loop or if it's the transition after the loop\r\n\t\t\tif (this.channelsIndex === this.states[this.activeState].gradients.length - 1) {\r\n\t\t\t\tisLooping = true;\r\n\t\t\t\t\r\n\t\t\t} else if (this.channelsIndex === this.states[this.activeState].gradients.length) {\r\n\t\t\t\tthis.channelsIndex = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Checking the next gradient to send in args of an event and a callback\r\n\t\t\tnextGradient = this.states[this.activeState].gradients[this.channelsIndex + 1] === undefined ?\r\n\t\t\t\tthis.states[this.activeState].gradients[0] :\r\n\t\t\t\tthis.states[this.activeState].gradients[this.channelsIndex + 1];\r\n\r\n\t\t\t// Compute the colors for the transition and render a new frame\r\n\t\t\tthis.setColors();\r\n\t\t\tthis.animation = requestAnimationFrame(this.animateColors.bind(this));\r\n\t\t\t\r\n\t\t\t// Callback and Event\r\n\t\t\tif (this.callbacks.onGradientChange) {\r\n\t\t\t\tthis.callbacks.onGradientChange({\r\n\t\t\t\t\tisLooping: isLooping,\r\n\t\t\t\t\tcolorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\r\n\t\t\t\t\tcolorsTo: nextGradient,\r\n\t\t\t\t\tactiveState: this.activeState\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis.canvas.dispatchEvent(this.events.gradientChange({\r\n\t\t\t\tisLooping: isLooping,\r\n\t\t\t\tcolorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\r\n\t\t\t\tcolorsTo: nextGradient,\r\n\t\t\t\tactiveState: this.activeState\r\n\t\t\t}));\r\n\r\n\t\t// Else if it was the last gradient on the list and the loop mode is off\r\n\t\t} else {\r\n\t\t\tcancelAnimationFrame(this.animation);\r\n\r\n\t\t\t// Callback and Event\r\n\t\t\tif (this.callbacks.onEnd) this.callbacks.onEnd();\r\n\t\t\tthis.canvas.dispatchEvent(new CustomEvent('granim:end'));\r\n\t\t}\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}