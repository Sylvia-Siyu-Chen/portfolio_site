{"ast":null,"code":"'use strict';\n\nmodule.exports = function (progressPercent) {\n  var _this = this,\n      activeChannel,\n      activeChannelPos,\n      i,\n      j; // Loop through each colors of the active gradient\n\n\n  for (i = 0; i < this.activeColors.length; i++) {\n    // Generate RGBA colors\n    for (j = 0; j < 4; j++) {\n      // If color value [0-255] round to the integer,\n      // Else if opacity [0-1] round to 2 decimals\n      activeChannel = _this.activeColors[i][j] + (j !== 3 ? Math.ceil(_this.activeColorsDiff[i][j] / 100 * progressPercent) : Math.round(_this.activeColorsDiff[i][j] / 100 * progressPercent * 100) / 100); // Prevent colors values from going < 0 & > 255\n\n      if (activeChannel <= 255 && activeChannel >= 0) {\n        _this.currentColors[i][j] = activeChannel;\n      }\n    } // Generate gradient color position\n\n\n    activeChannelPos = parseFloat((_this.activeColorsPos[i] + _this.activeColorsPosDiff[i] / 100 * progressPercent).toFixed(4));\n\n    if (activeChannelPos <= 1 && activeChannelPos >= 0) {\n      _this.currentColorsPos[i] = activeChannelPos;\n    }\n  }\n\n  this.makeGradient();\n};","map":{"version":3,"sources":["/Users/sylv/Desktop/coding/portfolio-site/node_modules/granim/lib/refreshColorsAndPos.js"],"names":["module","exports","progressPercent","_this","activeChannel","activeChannelPos","i","j","activeColors","length","Math","ceil","activeColorsDiff","round","currentColors","parseFloat","activeColorsPos","activeColorsPosDiff","toFixed","currentColorsPos","makeGradient"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,UAASC,eAAT,EAA0B;AAC1C,MAAIC,KAAK,GAAG,IAAZ;AAAA,MAAkBC,aAAlB;AAAA,MAAiCC,gBAAjC;AAAA,MAAmDC,CAAnD;AAAA,MAAsDC,CAAtD,CAD0C,CAG1C;;;AACA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKE,YAAL,CAAkBC,MAAlC,EAA0CH,CAAC,EAA3C,EAA+C;AAE9C;AACA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAAhB,EAAmBA,CAAC,EAApB,EAAwB;AACvB;AACA;AACAH,MAAAA,aAAa,GAAGD,KAAK,CAACK,YAAN,CAAmBF,CAAnB,EAAsBC,CAAtB,KACdA,CAAC,KAAK,CAAN,GACEG,IAAI,CAACC,IAAL,CAAUR,KAAK,CAACS,gBAAN,CAAuBN,CAAvB,EAA0BC,CAA1B,IAA+B,GAA/B,GAAqCL,eAA/C,CADF,GAEEQ,IAAI,CAACG,KAAL,CAAYV,KAAK,CAACS,gBAAN,CAAuBN,CAAvB,EAA0BC,CAA1B,IAA+B,GAA/B,GAAqCL,eAAtC,GAAyD,GAApE,IAA2E,GAH/D,CAAhB,CAHuB,CASvB;;AACA,UAAIE,aAAa,IAAI,GAAjB,IAAwBA,aAAa,IAAI,CAA7C,EAAgD;AAC/CD,QAAAA,KAAK,CAACW,aAAN,CAAoBR,CAApB,EAAuBC,CAAvB,IAA4BH,aAA5B;AACA;AACD,KAhB6C,CAkB9C;;;AACAC,IAAAA,gBAAgB,GAAGU,UAAU,CAAC,CAACZ,KAAK,CAACa,eAAN,CAAsBV,CAAtB,IAC7BH,KAAK,CAACc,mBAAN,CAA0BX,CAA1B,IAA+B,GAA/B,GAAqCJ,eADT,EAE5BgB,OAF4B,CAEpB,CAFoB,CAAD,CAA7B;;AAIA,QAAIb,gBAAgB,IAAI,CAApB,IAAyBA,gBAAgB,IAAI,CAAjD,EAAoD;AACnDF,MAAAA,KAAK,CAACgB,gBAAN,CAAuBb,CAAvB,IAA4BD,gBAA5B;AACA;AACD;;AAED,OAAKe,YAAL;AACA,CAjCD","sourcesContent":["'use strict';\r\n\r\nmodule.exports = function(progressPercent) {\r\n\tvar _this = this, activeChannel, activeChannelPos, i, j;\r\n\r\n\t// Loop through each colors of the active gradient\r\n\tfor (i = 0; i < this.activeColors.length; i++) {\r\n\r\n\t\t// Generate RGBA colors\r\n\t\tfor (j = 0; j < 4; j++) {\r\n\t\t\t// If color value [0-255] round to the integer,\r\n\t\t\t// Else if opacity [0-1] round to 2 decimals\r\n\t\t\tactiveChannel = _this.activeColors[i][j] +\r\n\t\t\t\t(j !== 3\r\n\t\t\t\t\t? Math.ceil(_this.activeColorsDiff[i][j] / 100 * progressPercent)\r\n\t\t\t\t\t: Math.round((_this.activeColorsDiff[i][j] / 100 * progressPercent) * 100) / 100\r\n\t\t\t\t);\r\n\r\n\t\t\t// Prevent colors values from going < 0 & > 255\r\n\t\t\tif (activeChannel <= 255 && activeChannel >= 0) {\r\n\t\t\t\t_this.currentColors[i][j] = activeChannel;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate gradient color position\r\n\t\tactiveChannelPos = parseFloat((_this.activeColorsPos[i] +\r\n\t\t\t(_this.activeColorsPosDiff[i] / 100 * progressPercent)\r\n\t\t).toFixed(4));\r\n\r\n\t\tif (activeChannelPos <= 1 && activeChannelPos >= 0) {\r\n\t\t\t_this.currentColorsPos[i] = activeChannelPos;\r\n\t\t}\r\n\t}\r\n\r\n\tthis.makeGradient();\r\n};\r\n"]},"metadata":{},"sourceType":"script"}